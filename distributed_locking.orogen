name "distributed_locking"

using_library "distributed_locking"
using_library "fipa_acl"

import_types_from "fipa_acl/message_generator/serialized_letter.h"
import_types_from "distributed_locking/DLM.hpp"
import_types_from "distributed_locking/Agent.hpp"
import_types_from "base"

task_context "DistributedLockingTask" do
    needs_configuration
    
    property "self", "fipa/Agent"
    property "protocol", "fipa/distributed_locking/protocol/Protocol"

    output_port("lettersOut", "/fipa/SerializedLetter").
        doc("Output port for FIPA letters, that will be sent by the MTS")
    input_port("lettersIn", "/fipa/SerializedLetter").
        doc("Input port for FIPA letters from the MTS")
    port_driven ("lettersIn")
    
    
    operation("lock").
        argument("resource", "/std/string/", "the name of the resource").
        argument("agents", "/std/vector</fipa/Agent >", "the agents to communicate with for this lock").
        doc("Tries to lock the resource. isLocked has to be called subsequently to check the status.")
    
    operation("unlock").
        argument("resource", "/std/string/", "the name of the resource").
        doc("Unlocks the resource.")
        
    operation("getLockState").
        returns("/fipa/distributed_locking/lock_state/LockState").
        argument("resource", "/std/string/", "the name of the resource").
        doc("Gets the lock state for the given resource.")
    
    operation("getAgent").
        returns("fipa/Agent").
        doc("Returns the agent managed by the underlying dlm.")
end

deployment "dlm_test" do
    do_not_install
    (0..4).each do |i|
        task("dlm_#{i}", "distributed_locking::DistributedLockingTask")
        #.periodic(0.1) # WHY?
    end
end